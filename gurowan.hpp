// Copyright (c) 2015 Nihat Engin Toklu < http://github.com/engintoklu >
//
// Boost Software License - Version 1.0 - August 17, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef _GRB_GLPK_HPP
#define _GRB_GLPK_HPP

//#include <glpk.h>
#include <map>
#include <list>
#include <string>
#include <sstream>
#include <fstream>
#include <cstdio>
#include <cstdlib>

// TODO: model.setObjective()

//#define GRB_CONTINUOUS GLP_CV
//#define GRB_INTEGER GLP_IV
//#define GRB_BINARY GLP_BV

#define GRB_CONTINUOUS 'C'
#define GRB_INTEGER    'I'
#define GRB_BINARY     'B'

#define GRB_MINIMIZE   1
#define GRB_MAXIMIZE   -1

#define GUROWANKENOBI_ERROR 9999999

#define GRB_LOADED          1
#define GRB_OPTIMAL         2
#define GRB_INFEASIBLE      3
#define GRB_INF_OR_UNBD     4
#define GRB_UNBOUNDED       5
#define GRB_CUTOFF          6
#define GRB_ITERATION_LIMIT 7
#define GRB_NODE_LIMIT      8
#define GRB_TIME_LIMIT      9
#define GRB_SOLUTION_LIMIT  10
#define GRB_INTERRUPTED     11
#define GRB_NUMERIC         12
#define GRB_SUBOPTIMAL      13
#define GRB_INPROGRESS      14

#if defined(WIN32) || defined(_WIN32) || defined(__WIN32)
#define GUROWANKENOBI_WIN32
#endif

namespace gurowan_utils
{
#if defined(GUROWANKENOBI_WIN32)
    std::FILE *pipe_open(std::string s, std::string mode="rt")
    {
        return _popen(s.c_str(), mode.c_str());
    }

    int pipe_close(std::FILE *f)
    {
        return _pclose(f);
    }

    std::string quote_for_shell(std::string arg, bool fix_percentage=true)
    {
        std::string result;
        int backslashes = 0;

        char z[2];
        z[1] = '\0';

        for (size_t i = 0; i < arg.size(); ++i)
        {
            char c;

            c = arg[i];
            z[0] = c;

            if (c == '\\')
            {
                backslashes++;
            }
            else
            {
                if (c == '"')
                {
                    if (backslashes > 0)
                    {
                        for (int bs = 0; bs < backslashes; ++bs)
                        {
                            result += "\\\\";
                        }
                        result += "\\\"";
                    }
                    else
                    {
                        result += "\"\"";
                    }
                }
                else
                {
                    for (int bs = 0; bs < backslashes; ++bs)
                    {
                        result += "\\";
                    }

                    if (fix_percentage && c == '%')
                    {
                        result += "\"^%\"";
                    }
                    else
                    {
                        result += z;
                    }
                }
                backslashes = 0;
            }

        }
        for (int bs = 0; bs < backslashes; ++bs)
        {
            result += "\\\\";
        }

        return "\"" + result + "\"";
    }
#else
    std::FILE *pipe_open(std::string s, std::string mode="rt")
    {
        return popen(s.c_str(), mode.c_str());
    }

    int pipe_close(std::FILE *f)
    {
        return pclose(f);
    }

    std::string quote_for_shell(std::string arg)
    {
        // this is a quoting mechanism compatible with sh, bash, and zsh
        char z[2];
        z[1] = '\0';
        std::string result;
        for (size_t i = 0; i < arg.size(); ++i)
        {
            char c;
            c = arg[i];
            z[0] = c;

            if (c == '\'')
            {
                result += "'\"'\"'";
            }
            else if (c == '\\')
            {
                result += "'\\\\'";
            }
            else
            {
                result += z;
            }
        }
        return "'" + result + "'";
    }

#endif

    std::string join_into_command_line(std::list<std::string> &arguments)
    {
        std::string result;
        bool first = true;

        for (std::list<std::string>::iterator it = arguments.begin();
             it != arguments.end();
             ++it)
        {
            if (first)
            {
                first = false;
            }
            else
            {
                result += " ";
            }

            result += quote_for_shell(*it);
        }

#if defined(GUROWANKENOBI_WIN32)
        if (result.size() >= 2)
        {
            if (result[0] == '\"'
                && result[result.size() - 1] == '\"')
            {
                result = "\"" + result + "\"";
            }
        }
#endif

        return result;
    }

    bool string_has(std::string big, std::string what)
    {
        return big.find(what) != std::string::npos;
    }
}

class GRBException
{
private:
    int code;
    std::string message;

    void clone_from(const GRBException &other)
    {
        code = other.code;
        message = other.message;
    }

public:
    GRBException()
    {
        code = GUROWANKENOBI_ERROR;
    }

    GRBException(std::string msg)
    {
        code = GUROWANKENOBI_ERROR;
        message = msg;
    }

    GRBException(std::string msg, int c)
    {
        code = c;
        message = msg;
    }

    int getErrorCode() const
    {
        return code;
    }

    std::string getMessage() const
    {
        return message;
    }

    GRBException(const GRBException &other)
    {
        clone_from(other);
    }

    GRBException &operator =(const GRBException &other)
    {
        clone_from(other);
        return *this;
    }
};

template <char C>
class Attribute
{
    int data;
public:
    static const char attrtype = C;

    Attribute(int data)
    {
        this->data = data;
    }

    Attribute(const Attribute &other)
    {
        data = other.data;
    }

    Attribute &operator =(const Attribute &other)
    {
        data = other.data;
        return *this;
    }

    bool operator ==(const Attribute &other)
    {
        return data == other.data;
    }

    bool operator !=(const Attribute &other)
    {
        return data != other.data;
    }

    operator int() const
    {
        return data;
    }
};

typedef Attribute<'i'> GRB_IntAttr;
typedef Attribute<'c'> GRB_CharAttr;
typedef Attribute<'s'> GRB_StringAttr;
typedef Attribute<'d'> GRB_DoubleAttr;

GRB_IntAttr GRB_IntAttr_NumVars(0);
GRB_IntAttr GRB_IntAttr_NumConstrs(1);
GRB_IntAttr GRB_IntAttr_ModelSense(1);
GRB_IntAttr GRB_IntAttr_Status(2);

GRB_DoubleAttr GRB_DoubleAttr_X(0);
GRB_DoubleAttr GRB_DoubleAttr_ObjVal(1);

class GRBEnv
{
public:
    std::string glpsol_path;
    std::string temp_model_file;

private:
    void clone_from(const GRBEnv &other)
    {
        glpsol_path = other.glpsol_path;
        temp_model_file = other.temp_model_file;
    }

public:
    GRBEnv():
        glpsol_path("glpsol"),
        temp_model_file("gurowankenobi_model.tmp")
    {
    }

    GRBEnv(const GRBEnv &other)
    {
        clone_from(other);
    }

    GRBEnv &operator=(const GRBEnv &other)
    {
        clone_from(other);
        return *this;
    }

};


class GRBModel;
class GRBConstr;
class GRBLinExpr;

class VarInfo
{
public:
    double lbound;
    double ubound;
    double coefficient;
    char vartype;
    std::string varname;

    double x;

private:
    void clone_from(const VarInfo &other)
    {
        lbound = other.lbound;
        ubound = other.ubound;
        coefficient = other.coefficient;
        vartype = other.vartype;
        varname = other.varname;
        x = other.x;
    }

public:
    VarInfo(double lb, double ub, double obj, char vtype, std::string vname)
    {
        lbound = lb;
        ubound = ub;
        coefficient = obj;
        vartype = vtype;
        varname = vname;
        x = 0;
    }

    VarInfo()
    {
    }

    VarInfo(const VarInfo &other)
    {
        clone_from(other);
    }

    VarInfo &operator =(const VarInfo &other)
    {
        clone_from(other);
        return *this;
    }

};

class GRBVar
{
private:

    std::string varname;
    GRBModel *model;

    void clone_from(const GRBVar &other)
    {
        varname = other.varname;
        model = other.model;
    }

public:

    GRBVar()
    {
        this->model = NULL;
    }

    //GRBVar(GRBModel *model, double lbound, double ubound, double coefficient, char vartype, std::string varname)
    //{
    //    this->model = model;
    //    this->lbound = lbound;
    //    this->ubound = ubound;
    //    this->coefficient = coefficient;
    //    this->vartype = vartype;
    //    this->varname = varname;
    //}

    GRBVar(GRBModel *model, std::string varname)
    {
        this->model = model;
        this->varname = varname;
    }

    GRBVar(const GRBVar &other)
    {
        clone_from(other);
    }

    double get(GRB_DoubleAttr q) const
        throw(GRBException);

    GRBVar &operator=(const GRBVar &other)
    {
        clone_from(other);
        return *this;
    }

    GRBLinExpr operator +(const GRBVar &v) const;
    GRBLinExpr operator -(const GRBVar &v) const;
    GRBLinExpr operator +(double x) const;
    GRBLinExpr operator -(double x) const;
    GRBLinExpr operator -() const;
    GRBLinExpr operator *(double x) const;

    GRBConstr operator ==(const GRBLinExpr &rhs) const;
    GRBConstr operator >=(const GRBLinExpr &rhs) const;
    GRBConstr operator <=(const GRBLinExpr &rhs) const;

    std::string toString() const
    {
        return varname;
    }
};


class GRBLinExpr
{
private:
    std::map<std::string, double> terms;
    double constant;

    void clone_from(const GRBLinExpr &other)
    {
        terms = other.terms;
        constant = other.constant;
    }

public:
    GRBLinExpr()
    {
        constant = 0;
    }

    GRBLinExpr(double x)
    {
        constant = x;
    }

    GRBLinExpr(const GRBVar &v)
    {
        terms[v.toString()] = 1;
        constant = 0;
    }

    GRBLinExpr(const GRBLinExpr &other)
    {
        clone_from(other);
    }

    GRBLinExpr &operator =(const GRBLinExpr &other)
    {
        clone_from(other);
        return *this;
    }

    GRBLinExpr &operator =(double x)
    {
        terms.clear();
        constant = x;
        return *this;
    }

    void setConstant(double x)
    {
        constant = x;
    }

    double getConstant() const
    {
        return constant;
    }

    void addTerm(double c, std::string vname)
    {
        if (terms.find(vname) == terms.end())
        {
            terms[vname] = c;
        }
        else
        {
            terms[vname] += c;
        }
    }

    void addTerm(double c, GRBVar v)
    {
        addTerm(c, v.toString());
    }

    void addTerm(double c)
    {
        constant += c;
    }

    std::string toString(bool usingAsterisk=false) const
    {
        std::stringstream result;

        if (terms.empty())
        {
            result << constant;
            return result.str();
        }

        bool first_step = true;

        for (std::map< std::string, double >::const_iterator it = terms.begin();
             it != terms.end();
             ++it)
        {
            double coeff;
            std::string vname;

            coeff = it->second;
            vname = it->first;

            char multiplication;

            if (usingAsterisk)
            {
                multiplication = '*';
            }
            else
            {
                multiplication = ' ';
            }

            if (first_step)
            {
                if (coeff == 1)
                {
                    result << vname;
                }
                else if (coeff == -1)
                {
                    result << "-" << vname;
                }
                else
                {
                    result << coeff << multiplication << vname;
                }
                first_step = false;
            }
            else
            {
                if (coeff == 1)
                {
                    result << " + " << vname;
                }
                else if (coeff == -1)
                {
                    result << " - " << vname;
                }
                else if (coeff < 0)
                {
                    result << " - " << (-coeff) << multiplication << vname;
                }
                else
                {
                    result << " + " << coeff << multiplication << vname;
                }
            }
        }

        if (constant < 0)
        {
            result << " - " << (-constant);
        }
        else if (constant > 0)
        {
            result << " + " << constant;
        }

        return result.str();
    }

    // DONE: operator overloading: linexpr1 / n -> linexpr2
    // DONE: operator overloading: linexpr1 * n -> linexpr2
    // DONE: operator overloading: n * linexpr1 -> linexpr2
    // DONE: operator overloading: linexpr1 + linexpr2 -> linexpr3
    // DONE: operator overloading: linexpr1 - linexpr2 -> linexpr3
    // DONE: operator overloading: /= *= += -=

    // DONE: operator overloading: linexpr1 >= linexpr2 -> GRBConstr
    // DONE: operator overloading: linexpr1 <= linexpr2 -> GRBConstr
    // DONE: operator overloading: linexpr1 == linexpr2 -> GRBConstr

    GRBLinExpr operator -() const
    {
        GRBLinExpr result(*this);
        for (std::map<std::string, double>::iterator it = result.terms.begin();
             it != result.terms.end();
             ++it)
        {
            it->second *= -1;
        }

        result.constant *= -1;
        return result;
    }

    GRBLinExpr &operator /=(double x)
    {
        for (std::map<std::string, double>::iterator it = terms.begin();
             it != terms.end();
             ++it)
        {
            it->second /= x;
        }
        constant /= x;
        return *this;
    }

    GRBLinExpr &operator *=(double x)
    {
        for (std::map<std::string, double>::iterator it = terms.begin();
             it != terms.end();
             ++it)
        {
            it->second *= x;
        }
        constant *= x;
        return *this;
    }

    GRBLinExpr &operator +=(double x)
    {
        addTerm(x);
        return *this;
    }

    GRBLinExpr &operator -=(double x)
    {
        addTerm(-x);
        return *this;
    }

    GRBLinExpr &operator +=(const GRBLinExpr &x)
    {
        for (std::map<std::string, double>::const_iterator it = x.terms.begin();
             it != x.terms.end();
             ++it)
        {
            addTerm(it->second, it->first);
        }
        addTerm(x.constant);
        return *this;
    }

    GRBLinExpr &operator -=(const GRBLinExpr &x)
    {
        for (std::map<std::string, double>::const_iterator it = x.terms.begin();
             it != x.terms.end();
             ++it)
        {
            addTerm(-(it->second), it->first);
        }
        addTerm(-(x.constant));
        return *this;
    }

    GRBLinExpr operator /(double x) const
    {
        GRBLinExpr result(*this);
        result /= x;
        return result;
    }

    GRBLinExpr operator *(double x) const
    {
        GRBLinExpr result(*this);
        result *= x;
        return result;
    }

    GRBLinExpr operator +(double x) const
    {
        GRBLinExpr result(*this);
        result += x;
        return result;
    }

    GRBLinExpr operator +(const GRBLinExpr &x) const
    {
        GRBLinExpr result(*this);
        result += x;
        return result;
    }

    GRBLinExpr operator -(double x) const
    {
        GRBLinExpr result(*this);
        result -= x;
        return result;
    }

    GRBLinExpr operator -(const GRBLinExpr &x) const
    {
        GRBLinExpr result(*this);
        result -= x;
        return result;
    }

    friend GRBLinExpr operator *(double x, const GRBLinExpr &e);
    friend GRBLinExpr operator +(double x, const GRBLinExpr &e);
    friend GRBLinExpr operator -(double x, const GRBLinExpr &e);

    GRBConstr operator ==(const GRBLinExpr &rhs) const;
    GRBConstr operator >=(const GRBLinExpr &rhs) const;
    GRBConstr operator <=(const GRBLinExpr &rhs) const;
};

GRBLinExpr operator *(double x, const GRBLinExpr &e) {return e * x;}
GRBLinExpr operator +(double x, const GRBLinExpr &e) {return e + x;}
GRBLinExpr operator -(double x, const GRBLinExpr &e) {return (-e) + x;}


class GRBConstr
{
private:
    GRBModel *model;
    int row_number;
    GRBLinExpr lhs;
    char sense;
    double rhs;
    std::string constrname;

    void clone_from(const GRBConstr &other)
    {
        model = other.model;
        row_number = other.row_number;
        lhs = other.lhs;
        rhs = other.rhs;
        sense = other.sense;
        constrname = other.constrname;
    }

public:
    GRBConstr()
    {
        row_number = -1;
        model = NULL;
        sense = '=';
    }

    GRBConstr(const GRBLinExpr &e1, char sens, const GRBLinExpr &e2)
    {
        sense = sens;
        lhs = e1 - e2;
        rhs = lhs.getConstant();
        lhs -= rhs;
    }

    GRBConstr(int row_number, GRBModel *model, const GRBConstr &other, std::string constrname)
    {
        clone_from(other);
        this->row_number = row_number;
        this->model = model;
        this->constrname = constrname;
    }

    GRBConstr(const GRBConstr &other)
    {
        clone_from(other);
    }

    GRBConstr &operator=(const GRBConstr &other)
    {
        clone_from(other);
        return *this;
    }

    std::string toString(bool usingAsterisk=false, int row_index=-1) const
    {
        std::stringstream result;
        if (!(constrname.empty()))
        {
            result << constrname << ": ";
        }
        else if (row_index >= 0)
        {
            result << "__Constr" << row_index << ": ";
        }

        result << lhs.toString(usingAsterisk);

        if (sense == '=')
        {
            result << " = ";
        }
        else if (sense == '>')
        {
            result << " >= ";
        }
        else if (sense == '<')
        {
            result << " <= ";
        }

        result << rhs;

        return result.str();
    }
};



class GRBModel
{
private:
    GRBEnv env;
    //glp_prob *prob;
    std::map<std::string, VarInfo> variables;
    std::list<GRBConstr> constraints;

    int column_number;
    int row_number;

    int sense;

    double objval;
    int status;

public:
    GRBModel(const GRBEnv &env)
    {
        sense = GRB_MINIMIZE;
        this->env = env;
        row_number = 0;
        status = GRB_LOADED;
    }

    inline void update() { }

    void set(GRB_IntAttr q, int v)
        throw(GRBException)
    {
        if (q == GRB_IntAttr_ModelSense)
        {
            sense = v;
        }
        else
        {
            throw GRBException("Unsupported attribute");
        }
    }

    int get(GRB_IntAttr q) const
        throw(GRBException)
    {
        if (q == GRB_IntAttr_ModelSense)
        {
            return sense;
        }
        else if (q == GRB_IntAttr_Status)
        {
            return status;
        }
        else if (q == GRB_IntAttr_NumVars)
        {
            return int(variables.size());
        }
        else if (q == GRB_IntAttr_NumConstrs)
        {
            return int(constraints.size());
        }
        else
        {
            throw GRBException("Unsupported attribute");
        }
    }

    double get(GRB_DoubleAttr q) const
        throw(GRBException)
    {
        if (q == GRB_DoubleAttr_ObjVal)
        {
            return objval;
        }
        else
        {
            throw GRBException("Unsupported attribute");
        }
    }

    double getX(std::string vname) const
    {
        return variables.at(vname).x;
    }

    GRBVar addVar(double lbound, double ubound, double coeff,
        char vartype, std::string varname = "");

    GRBConstr addConstr(const GRBConstr &c, std::string constrname = "");

    std::string toStringLP() const
    {
        std::stringstream result;

        // objective sense
        if (sense == GRB_MINIMIZE)
        {
            result << "Minimize" << std::endl;
        }
        else if (sense == GRB_MAXIMIZE)
        {
            result << "Maximize" << std::endl;
        }

        // objective
        GRBLinExpr obj;
        for (std::map<std::string, VarInfo>::const_iterator it = variables.begin();
             it != variables.end();
             ++it)
        {
            std::string vname;
            VarInfo vinfo;

            vname = it->first;
            vinfo = it->second;

            if (vinfo.coefficient != 0)
            {
                obj.addTerm(vinfo.coefficient, vname);
            }
        }
        result << obj.toString() << std::endl;

        // constraints
        result << "Subject To" << std::endl;
        for (std::list<GRBConstr>::const_iterator itc = constraints.begin();
             itc != constraints.end();
             ++itc)
        {
            result << itc->toString() << std::endl;
        }

        // boundaries
        result << "Bounds" << std::endl;
        for (std::map<std::string, VarInfo>::const_iterator it = variables.begin();
             it != variables.end();
             ++it)
        {
            std::string vname;
            VarInfo vinfo;

            vname = it->first;
            vinfo = it->second;

            result << vinfo.lbound << " <= " << vname << " <= " << vinfo.ubound << std::endl;
        }

        // integer variables
        result << "Integer" << std::endl;
        for (std::map<std::string, VarInfo>::const_iterator it = variables.begin();
             it != variables.end();
             ++it)
        {
            std::string vname;
            VarInfo vinfo;

            vname = it->first;
            vinfo = it->second;

            if (vinfo.vartype == GRB_INTEGER)
            {
                result << vname << std::endl;
            }
        }

        // binary variables
        result << "Binary" << std::endl;
        for (std::map<std::string, VarInfo>::const_iterator it = variables.begin();
             it != variables.end();
             ++it)
        {
            std::string vname;
            VarInfo vinfo;

            vname = it->first;
            vinfo = it->second;

            if (vinfo.vartype == GRB_BINARY)
            {
                result << vname << std::endl;
            }
        }

        result << "End";

        return result.str();
    }

    inline std::string toString() const
    {
        return toStringLP();
    }

    std::string toStringGMPL() const
    {
        std::stringstream result;

        // variables
        for (std::map<std::string, VarInfo>::const_iterator it = variables.begin();
             it != variables.end();
             ++it)
        {
            std::string vname;
            VarInfo vinfo;

            vname = it->first;
            vinfo = it->second;

            result << "var " << vinfo.varname;

            if (vinfo.vartype == GRB_INTEGER)
            {
                result << ", integer";
            }
            else if (vinfo.vartype == GRB_BINARY)
            {
                result << ", binary";
            }

            result << ", >= " << vinfo.lbound;
            result << ", <= " << vinfo.ubound;
            result << ";" << std::endl;
        }


        // objective sense
        if (sense == GRB_MINIMIZE)
        {
            result << "minimize __obj: ";
        }
        else if (sense == GRB_MAXIMIZE)
        {
            result << "maximize __obj: ";
        }

        // objective
        GRBLinExpr obj;
        for (std::map<std::string, VarInfo>::const_iterator it = variables.begin();
             it != variables.end();
             ++it)
        {
            std::string vname;
            VarInfo vinfo;

            vname = it->first;
            vinfo = it->second;

            if (vinfo.coefficient != 0)
            {
                obj.addTerm(vinfo.coefficient, vname);
            }
        }
        result << obj.toString(true) << ";" << std::endl;

        // constraints
        int row_index = 0;
        for (std::list<GRBConstr>::const_iterator itc = constraints.begin();
             itc != constraints.end();
             ++itc)
        {
            result << itc->toString(true, row_index) << ";" << std::endl;
            ++row_index;
        }

        // show results
        result << "solve;" << std::endl;
        //result << "display \"=== RESULTS ===\";" << std::endl;
        //result << "display \"objective:\";" << std::endl;
        //result << "display __obj;" << std::endl;
        //result << "display \"status:\";" << std::endl;
        //result << "display __obj.status;" << std::endl;
        result << "printf \"=== RESULTS ===\\n\";" << std::endl;
        result << "printf \"objective=%f\\n\", __obj;" << std::endl;
        result << "printf \"status=%f\\n\", __obj.status;" << std::endl;

        for (std::map<std::string, VarInfo>::const_iterator it = variables.begin();
             it != variables.end();
             ++it)
        {
            std::string vname;
            VarInfo vinfo;

            vname = it->first;
            vinfo = it->second;

            //result << "display \"" << vname << "\";" << std::endl;
            //result << "display " << vname << ";" << std::endl;
            result << "printf \""<< vname << "=%f\\n\", " << vname << ";" << std::endl;
        }

        // end
        result << "end;" << std::endl;

        return result.str();
    }

//private:
//    void execute_solver()
//    {
//        system((env.glpsol_path
//                + " --math " + env.temp_model_file
//                + " > " + env.temp_results_file).c_str());
//    }

public:
    void optimize()
    {
        std::string gmpl;
        gmpl = toStringGMPL();

        std::ofstream outf(env.temp_model_file.c_str());
        outf << gmpl;
        outf.close();

        std::list<std::string> cmdline;
        cmdline.push_back(env.glpsol_path);
        cmdline.push_back("--math");
        cmdline.push_back(env.temp_model_file);

        std::FILE *pf;
        pf = gurowan_utils::pipe_open(
            gurowan_utils::join_into_command_line(cmdline));

        std::string line;
        bool results_section = false;
        int result_line = 0;
        char cline[512];
        while (std::fgets(cline, 512, pf))
        {
            line = cline;

            // remove line ending characters
            for (int ii = int(line.size()) - 1; ii >= 0; --ii)
            {
                if (line[ii] != '\n' && line[ii] != '\r')
                {
                    line = line.substr(0, ii + 1);
                    break;
                }
            }


            if (!results_section)
            {
                if (line == "=== RESULTS ===")
                {
                    results_section = true;
                    result_line = 0;
                }
                else if (gurowan_utils::string_has(line, "PROBLEM HAS NO"))
                {
                    status = GRB_INFEASIBLE;
                }
                else if (gurowan_utils::string_has(line, "UNBOUNDED"))
                {
                    status = GRB_UNBOUNDED;
                }
                else if (gurowan_utils::string_has(line, "OPTIMAL"))
                {
                    status = GRB_OPTIMAL;
                }
            }
            else
            {
                std::string field, s_value;
                double value;
                bool found_equals = false;
                for (size_t i = 0; i < line.size(); ++i)
                {
                    char c;
                    c = line[i];

                    std::string z(" ");
                    z[0] = c;

                    if (c == '=')
                    {
                        found_equals = true;
                    }
                    else
                    {
                        if (!found_equals)
                        {
                            field += z;
                        }
                        else
                        {
                            s_value += z;
                        }
                    }
                }

                std::stringstream ss;
                ss << s_value;
                ss >> value;

                if (result_line == 0)
                {
                    objval = value;
                }
                else if (result_line == 1)
                {
                    // don't read status from here
                    // the number codes are incompatible
                    //status = int(value);
                }
                else
                {
                    variables[field].x = value;
                }

                ++result_line;
            }


            if (!results_section)
            {
                std::cout << line << std::endl;
            }
        }
        gurowan_utils::pipe_close(pf);

        // TODO: test this function
        // TODO: ok, we retrieved status, objval and x values. Now we need an interface to read these values
    }

private:
    GRBModel(const GRBModel &other);
    GRBModel &operator=(const GRBModel &other);

};


// operator overloadings -----------------------------------
GRBLinExpr GRBVar::operator +(const GRBVar &v) const
{
    GRBLinExpr result;
    result.addTerm(1, *this);
    result.addTerm(1, v);
    return result;
}

GRBLinExpr GRBVar::operator -(const GRBVar &v) const
{
    GRBLinExpr result;
    result.addTerm(1, *this);
    result.addTerm(-1, v);
    return result;
}

GRBLinExpr GRBVar::operator +(double x) const
{
    GRBLinExpr result;
    result.addTerm(1, *this);
    result.addTerm(x);
    return result;
}

GRBLinExpr GRBVar::operator -(double x) const
{
    GRBLinExpr result;
    result.addTerm(1, *this);
    result.addTerm(-x);
    return result;
}

GRBLinExpr GRBVar::operator -() const
{
    GRBLinExpr result;
    result.addTerm(-1, *this);
    return result;
}

GRBLinExpr GRBVar::operator *(double x) const
{
    GRBLinExpr result;
    result.addTerm(x, *this);
    return result;
}

GRBConstr GRBVar::operator ==(const GRBLinExpr &rhs) const
{
    return GRBConstr(*this, '=', rhs);
}

GRBConstr GRBVar::operator >=(const GRBLinExpr &rhs) const
{
    return GRBConstr(*this, '>', rhs);
}

GRBConstr GRBVar::operator <=(const GRBLinExpr &rhs) const
{
    return GRBConstr(*this, '<', rhs);
}



GRBConstr GRBLinExpr::operator ==(const GRBLinExpr &rhs) const
{
    return GRBConstr(*this, '=', rhs);
}

GRBConstr GRBLinExpr::operator >=(const GRBLinExpr &rhs) const
{
    return GRBConstr(*this, '>', rhs);
}

GRBConstr GRBLinExpr::operator <=(const GRBLinExpr &rhs) const
{
    return GRBConstr(*this, '<', rhs);
}


// ---------------------------------------------------------


GRBVar GRBModel::addVar(double lbound, double ubound, double coeff,
    char vartype, std::string varname)
{
    column_number++;

    if (varname.empty())
    {
        std::stringstream ss;
        ss << "____VAR____" << column_number;
        varname = ss.str();
    }

    VarInfo vi(lbound, ubound, coeff, vartype, varname);
    variables[varname] = vi;
    return GRBVar(this, varname);
}

GRBConstr GRBModel::addConstr(const GRBConstr &c, std::string constrname)
{
    GRBConstr newc(row_number, this, c, constrname);
    constraints.push_back(newc);
    row_number++;
    return newc;
}

double GRBVar::get(GRB_DoubleAttr q) const
    throw(GRBException)
{
    if (q == GRB_DoubleAttr_X)
    {
        return model->getX(varname);
    }
    else
    {
        throw GRBException("Unsupported attribute");
    }
}


#endif
